\section{Introduction}~\label{sec:intro}


Satisfiability (SAT) solving is a core tool in computer science, with applications in program verification \cite{BillionQueries}, planning \cite{planning}, and resolving long-standing mathematical conjectures \cite{chromaticnumber}. As its use grows, so has the need for more powerful and specialized solving techniques.

% It is most commonly solved using the conflict-driven clause learning (CDCL) framework. This framework explores the state space of possible solutions, while learning clauses when it reaches a conflict, to aid future explorations.
One such class of techniques is clause learning, where new, equisatisfiable clauses are added to the formula, shrinking the space of potential solutions. These learned clauses can act like lemmas for the solver to leverage. Crucially, they must preserve satisfiability: the original formula is satisfiable if and only if the formula with the additional clause is satisfiable.

% One can ensure that these clauses are satisfiable within the given proof system.

% for instance vivification and blocked clause addition. These techinques use other facts about the formula to learn clauses which are often useful for solving.
% However, the strength of these clauses is limited by the capabilities of the underlying proof system. Traditional SAT solvers typically use clausal proof systems based on resolution, which are known to lack polynomial-sized proofs for certain well-studied problems, such as the pigeonhole principle and the mutilated chessboard. To address this, a more expressive system based on propagation redundant (\pr) clauses has been proposed, offering short proofs for these challenging benchmarks. Despite their theoretical appeal, \pr clauses are hard to learn in practice. Existing methods require invoking another SAT solver to verify whether a clause is indeed \prâ€”a process that, due to the inherent intractability of SAT, can take exponential time in the worst case and remains difficult to integrate into modern, high-performance solvers.

The usefulness of clause learning, however, is fundamentally tied to the strength of the underlying proof system. Most SAT solvers rely on resolution-based proofs, which are ineffective for many hard instances. In particular, problems like the pigeonhole principle and the mutilated chessboard are known to require exponentially large resolution proofs. To overcome this limitation, researchers have proposed more expressive systems based on propagation redundant (\pr) clauses, which can admit short proofs for such problems.

Despite their theoretical power, learning \pr clauses remains a challenge. State-of-the-art techniques such as Satisfiability Driven Clause Learning (SDCL) rely on expensive SAT solver calls to verify that a candidate clause is \pr \cite{sadical}. This makes integration into high-performance solvers difficult and limits their practical impact.

In this work, we propose a new, more efficient approach to learning \pr clauses based on conditional autarkies. Our method identifies globally blocked clauses, which are guaranteed to preserve satisfiability. While globally blocked clauses can be too large and unwieldy, we introduce a shrinking procedure to extract compact, useful \pr clauses.

% Integrating \pr clause learning into a SAT solver is still an active area of study


To summarize, we make the following contributions: 

\begin{enumerate} 
    \item We introduce a method for learning globally blocked clauses in polynomial time using conditional autarkies. 
    \item We develop a shrinking technique to extract concise and useful \pr clauses from globally blocked clauses. 
    \item We implement these techniques in a tool, \tool, and evaluate it on a suite of benchmarks, demonstrating substantial performance improvements ... 
\end{enumerate}