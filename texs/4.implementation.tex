\section{Implementation}~\label{sec:implementation}

We implement our technique in \tool (a fork of \cadical
). We choose \cadical as it has shown strong performance in the SAT Competition.
For instance, a fork of CaDiCaL won in 2023~\cite{satcomp2023}. Our techniques
can be implemented in any CDCL SAT solver, but we leave this as future work.

By default, \tool spends 30 seconds searching for PR clauses in a preprocessing step. After this time limit, the solver exits and commences normal solving,
regardless of whether or not it has found any PR clauses. This adds $\sim\!800$ lines
of C++ code to \cadical and is implementable within any CDCL SAT solver.

We discuss three important design decisions in \tool:

\begin{enumerate}
  \item \textsf{shrink}: As discussed in \autoref{subsec:shrinking}, we may
  shrink a clause using the techniques inspired by greedy set cover.
  \item \textsf{filter-triv}: We filter out clauses that are trivial, i.e. if
  $\formula \impunit C$ for some clause $C$.
  \item \textsf{filter-long}: We filter out clauses that are longer than some
  set length $l$. We pick $l = 2$ as a default and thus only learn binary and unit
  clauses.
\end{enumerate}

The filter function in \autoref{alg:methodology} combines \textsf{filter-triv} and \textsf{filter-long},
disallowing trivial clauses or clauses with length greater than $2$.

Additionally, we describe three natural design decisions that we did not make:

\begin{enumerate}
  \item \textsf{longer-preprocess}: We choose 30 seconds as the default
  preprocessing time. However, we could choose a longer time limit, for instance
  100 seconds.
  \item \textsf{order-i}: On \autoref{alg:methodology} \autoref{line:choose-i},
  by default we pick $i$ randomly. However, we could choose $i$ based
  on some ordering. For instance, we could order literals $i$ by how frequently
  they occur in the original formula.
  \item \textsf{select-j}: On \autoref{alg:methodology} \autoref{line:choose-j},
  we iterate through all possible literals $j$. However, we
  could choose some subset of possible literals $j$. One such example is to pick $j$ from 
  the neighbors of $i$. This is implemented in \prelearn.
  The neighbors of $i$ include any literal $j$ that belongs to the same clause as
  a literal fixed by unit propagation on $i$ (including $i$ itself).
\end{enumerate}

We evaluate these heuristics in \autoref{sec:heuristics} and find that
\textsf{shrink}, \textsf{filter-triv}, and \textsf{filter-long} are all
beneficial. On the other hand \textsf{longer-preprocess}, \textsf{order-i}, and
\textsf{select-j} are not beneficial and can sometimes be harmful.
